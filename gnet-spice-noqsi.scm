
(define (spice-noqsi filename)
    (set-current-output-port(open-output-file filename))
    (write-header)
    (for-each reserve-refdes packages)
    (for-each collect-file packages)
    (for-each process-part packages)
    (if subcircuit (format #t "~A\n" subcircuit))
    (for-each (lambda (f) (format #t ".INCLUDE ~A\n" f)) files)
    (for-each (lambda (s) (format #t "~A\n" s)) cards)
    (if subcircuit (format #t ".ENDS\n"))
    (if (positive? error-count) (begin
        (format (current-error-port) "~A errors.\n" error-count)
        (primitive-exit 1))))

;; Write a header. Critical because SPICE may treat the first line
;; as a comment, even if it's not!

(define (write-header)
    (format #t "* ~A\n" (string-join (command-line) " "))
    (format #t
"* SPICE file generated by spice-noqsi version 20120101
* Send requests or bug reports to jpd@noqsi.com
"))

;; Collect file= attribute values

(define (collect-file refdes)
    (let ((f (gnetlist:get-package-attribute refdes "file")))
        (or (equal? f "unknown")
            (member f files)
            (set! files (cons f files)))))

;; List of files to include

(define files '())

;;

(define (process-part refdes)
    (let (
        (proto (gnetlist:get-package-attribute refdes "spice-prototype"))
        (card '()))
        (if (equal? proto "unknown") 
            (set! proto (lookup-proto refdes)))
	(set! card (expand-string refdes proto))
        (if (string-prefix-ci? ".subckt" card) 
            (subckt card)
            (set! cards (cons card cards)))))

;; If no spice-prototype attribute, get prototype by other means.

(define (lookup-proto refdes)
    (or 
        (hash-ref prototypes 
            (gnetlist:get-package-attribute refdes "device"))
        (hash-ref prototypes "unknown")))


;; record a subcircuit card, error if more than one

(define (subckt card)
    (if subcircuit
        (begin
            (format (current-error-port) 
                "More than one .subckt card generated!\n")
            (set! error-count (1+ error-count)))
        (set! subcircuit card)))
        
;; This variable will hold the .subckt card if given.
(define subcircuit #f)

;; List of cards in the circuit or subcircuit.
(define cards '())

;; If this isn't zero, exit with nonzero status when done.
(define error-count 0)

;; Get a list of numbers 1..n
;; Why isn't this basic function in Guile?

(define (range n)
    (if (positive? n) (append (range (1- n)) (list n)) '()))


;; gnetlist associates net with pinnumber, but traditionally SPICE
;; backends for gnetlist have keyed on pinseq. This function implements that.

(define (get-net-by-pinseq refdes n)
    (let* (
        (pinseq (number->string n))
        (pinnumber (gnetlist:get-attribute-by-pinseq 
            refdes pinseq "pinnumber")))

        (if (equal? pinnumber "unknown") 
            (pinseq-error refdes pinseq)
            (get-net refdes pinnumber))))

;; If we can't get the pinnumber, return "" for the net, which should be 
;; adequately toxic in the resulting file in most cases.
            
(define (pinseq-error refdes pinseq)
    (format (current-error-port)
        "Error: pinseq=~A not found for refdes=~A\n" pinseq refdes)
    (set! error-count (1+ error-count))
    "")

;; Get the net attached to a particular pin.
;; This really should be a helper in gnetlist.scm, or even
;; replace the partially broken (gnetlist:get-nets).

(define (get-net refdes pin)
    (car (gnetlist:get-nets refdes pin)))

;; Expand a string in context of a particular refdes

(define (expand-string refdes s)
    (string-concatenate (map
        (lambda (f) (check-field refdes f))
        (parse-fields s))))

;; Split string into whitespace and ink.

(define (parse-fields s)
    (let ((i (or 
        (field-skip s char-set:whitespace)
        (field-skip s 
            (char-set-complement char-set:whitespace)))))

        (if i    
            (append 
                (list (string-take s i))
                (parse-fields (string-drop s i)))
            (list s))))
 
;; string-skip is a bit difficult to use directly, yielding 0 for no match,
;; and #f when the whole string matches! Yielding only a positive number or
;; #f simplifies the logic above, so that's what I do here.

(define (field-skip s cs)
    (let ((i (string-skip s cs)))
    
    (if i 
        (if (zero? i) 
            #f 
            i)
        #f)))
   
;; Magic characters for field expansion

(define magic (string->char-set "?#=@%"))

;; Check field for magic, expand if necessary

(define (check-field refdes field)
    (let ((i (string-index field magic)))
        (if i 
            (expand-field refdes
                (string-take field i)
                (substring field i (+ i 1))
                (string-drop field (+ i 1)))
            field)))

;; Dispatch to the chosen expander

(define (expand-field refdes left key right)
    ((cond
        ((equal? key "?") expand-refdes)
        ((equal? key "#") expand-pin)
        ((equal? key "=") expand-attr)
        ((equal? key "@") expand-value)
        ((equal? key "%") expand-variable)) refdes left right))

;; Expand refdes, munging if asked

(define (expand-refdes refdes left right)
    (string-append
        (if (string-prefix-ci? left refdes) 
            refdes 
            (get-munged left refdes))
        right))

(define (get-value-or-default refdes attr default)
    (if (equal? value "unknown") default value))

;; forward and reverse refdes maps

(define munges (make-hash-table))
(define refdes-reserved (make-hash-table))

;; prevent munging from accidentally duplicating an existing refdes

(define (reserve-refdes r) (hash-set! refdes-reserved r r))

;; Get the munged version of refdes
;; "left" is the required prefix

(define (get-munged prefix refdes)
    (let ((munged
            (or 
                (hash-ref munges (list prefix refdes))
                (make-munged prefix refdes (string-append prefix refdes)))))
        (set! last-munged munged)
        munged))

(define last-munged "")

;; Make unique munged version

(define (make-munged prefix refdes candidate)
    (if (hash-ref refdes-reserved candidate)
        (make-munged prefix refdes (string-append candidate "X"))
        (begin
            (hash-set! refdes-reserved candidate refdes)
            (hash-set! munges (list prefix refdes) candidate))))

;; Get name of net connected to pin

(define (expand-pin refdes left right)
    (if (equal? left "")
        (get-net refdes right)
        (get-net left right)))

;; 

(define (expand-variable refdes left right)
    (string-append left
        (cond
            ((equal? right "refdes") last-refdes)
            ((equal? right "pinseq") (all-by-pinseq refdes))
            ((equal? right "io") (all-spice-io)))))

(define (all-by-pinseq refdes)
    (string-join
        (map
            (lambda (n) (get-net-by-pinseq refdes n))
            (range (length (gnetlist:get-pins refdes))))
        " "))


;; Expand attribute. Empty string if it doesn't exist, and no default given.

(define (expand-attr refdes name default)
    (let ((value (expand-value refdes name default)))
        (if (equal? value "")
            ""
            (string-append name "=" value))))

;; Expand value. Empty string if it doesn't exist, and no default given.

(define (expand-value refdes name default)
    (let ((value (gnetlist:get-package-attribute refdes name)))
        (if (equal? value "unknown")
            default
            value)))

;; Prototypes

(define prototypes (make-hash-table))

(define (spice-device device proto) (hash-set! prototypes device proto))

;; Standard prototypes

(spice-device "unknown" "? %pinseq value@ model-name@ spice-args@")
(spice-device "AOP-Standard" "X? %pinseq model-name@")
(spice-device "BATTERY" "V? #1 #2 spice-args@")
(spice-device "SPICE-cccs" "F? #1 #2 V? value@\n%refdes #3 #4 DC 0")
(spice-device "SPICE-ccvs" "H? #1 #2 V? value@\n%refdes #3 #4 DC 0")
(spice-device "directive" "value@")
(spice-device "include" "")               ; just a place to hang file=
(spice-device "options" ".OPTIONS value@")
(spice-device "CURRENT_SOURCE" "I? %pinseq value@")
(spice-device "K" "K? inductors@ value@")
(spice-device "SPICE-nullor" "N? %pinseq value@1E6")
(spice-device "SPICE-NPN" "Q? %pinseq model-name@ spice-args@ ic= temp=")
(spice-device "PNP_TRANSISTOR" "Q? %pinseq model-name@ spice-args@ ic= temp=")
(spice-device "NPN_TRANSISTOR" "Q? %pinseq model-name@ spice-args@ ic= temp=")
(spice-device "spice-subcircuit-LL" ".SUBCKT %pinseq# model-name@")
(spice-device "SPICE-VC-switch" "S? %pinseq model-name@ value@")
(spice-device "T-line" "T? %pinseq value@")
(spice-device "vac" "V? %pinseq value@")
(spice-device "SPICE-vccs" "G? %pinseq value@")
(spice-device "SPICE-vcvs" "E? %pinseq value@")
(spice-device "VOLTAGE_SOURCE" "V? %pinseq value@")
(spice-device "vexp" "V? %pinseq value@")
(spice-device "vpulse" "V? %pinseq value@")
(spice-device "vpwl" "V? %pinseq value@")
(spice-device "vsin" "V? %pinseq value@")
(spice-device "VOLTAGE_SOURCE" "V? %pinseq value@")
(spice-device 
    "CAPACITOR" "C? %pinseq value@ model-name@ spice-args@ l= w= area= ic=")
(spice-device "DIODE" "D? %pinseq model-name@ spice-args@ area= ic= temp=")
(spice-device "NMOS_TRANSISTOR" 
    "M? %pinseq model-name@ spice-args@ l= w= as= ad= pd= ps= nrd= nrs= temp= ic= m=")
(spice-device "PMOS_TRANSISTOR" 
    "M? %pinseq model-name@ spice-args@ l= w= as= ad= pd= ps= nrd= nrs= temp= ic= m=")
(spice-device "RESISTOR" 
    "R? %pinseq value@ model-name@ spice-args@ w= l= area= temp=")
(spice-device "DUAL_OPAMP" 
    "X1? #3 #2 #8 #4 #1 model-name@\nX2? #5 #6 #8 #4 #7 model-name@")
(spice-device "QUAD_OPAMP"
    "X? #3 #2 #11 #4 #1 model-name@
X? #5 #6 #11 #4 #7 model-name@
X? #10 #9 #11 #4 #8 model-name@
X? #12 #13 #11 #4 #14 model-name@")

